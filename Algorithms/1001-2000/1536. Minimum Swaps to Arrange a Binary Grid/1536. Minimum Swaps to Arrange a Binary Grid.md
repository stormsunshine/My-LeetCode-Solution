# 1536. Minimum Swaps to Arrange a Binary Grid
## Level
Medium

## Description
Given an `n x n` binary `grid`, in one step you can choose two **adjacent rows** of the grid and swap them.

A grid is said to be **valid** if all the cells above the main diagonal are **zeros**.

Return *the minimum number of steps* needed to make the grid valid, or **-1** if the grid cannot be valid.

The main diagonal of a grid is the diagonal that starts at cell `(1, 1)` and ends at cell `(n, n)`.

**Example 1:**

![Image text](https://assets.leetcode.com/uploads/2020/07/28/fw.jpg)

**Input:** grid = [[0,0,1],[1,1,0],[1,0,0]]

**Output:** 3

**Example 2:**

![Image text](https://assets.leetcode.com/uploads/2020/07/16/e2.jpg)

**Input:** grid = [[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,1,1,0]]

**Output:** -1

**Explanation:** All rows are similar, swaps have no effect on the grid.

**Example 3:**

![Image text](https://assets.leetcode.com/uploads/2020/07/16/e3.jpg)

**Input:** grid = [[1,0,0],[1,1,0],[1,1,1]]

**Output:** 0

**Constraints:**

* `n == grid.length`
* `n == grid[i].length`
* `1 <= n <= 200`
* `grid[i][j]` is `0` or `1`

## Solution
If the grid is valid, then for the `i`-th row, there must be at least `n - 1 - i` consecutive zeros at the end of the row. Therefore, for each row, count the number of consecutive zeros at the end of the row, and use an array to store the numbers.

Then use the idea of bubble sort (but not exactly the same as bubble sort). For the `i`-th row, suppose the number of consecutive zeros at the end of the row is `k`. If `k < n - 1 - i`, then find the first row after the `i`-th row that has at least `n - 1 - i` consecutive zeros at the end of the row, which is the `j`-th row, and swap the `j`-th row to the `i`-th row, where the number of swaps is increased by `j - i`. If there does not exist a row that has at least `n - 1 - i` consecutive zeros at the end of the row, return -1.

Finally, return the total number of swaps.
